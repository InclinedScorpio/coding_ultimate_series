1. Inversion Count/ Reverse Pair ( both similar question )
- Basically we need to reduce complexity from O(N^2) to O(NlogN)
- And things could be little better we have have 2 sorted array where we can check the requirement
- And merge sort we have these arrays and hence we can easlily check it there
- ðŸŒŸ In Reverse Pair, the method where we check is important as that logic is little tricky yet easy!

2. Unique Path Problem (Google Interview)
- Use recursion for (2^N)
- Use DP for O(N^2)
- Use Optimised space in tabular
- ðŸŒŸ Use combinations - O(N) -> RRD, RDR...

3. Dutch National Flag Algorithm/ Sort colors/ Sort 0, 1, 2
- In a single pass it's required to be done, with constant space
- DNF says take 3 ptr - low, mid, high
- Low's left contains 0, high's right will contain 2
- swap mid[i] with left if 0, if 2-swap with high
- move ptr accordingly!

4. Linked List Cycle II 
- Important to understand algorithm (If not known cant do the question)
- Important to understand how the same algo can work for 'Duplicate Element Question'
- 2 things are stated in algo 1) if there is cycle 2) start point of cycle
- After finding merger of fast and slow, just take another slow from head & keep moving 1 step (merger will be start of cycle)

5. Maximum Product Subarray
- Important to understand that array can have both -ve and 0
- Logic is to carry smallest and largest number possible everytimes
- So that if other - comes we can change that lowest to bigest or bigest to lowest(so it can become largest later when - comes again)
- Understand recursive approach in order to understand iterative(exactly same as recursion)

6. Find Duplicate Number in 1+N, numbered from 1-N
- clearly all items will be pointing inside the array itself
- Hence we can go for floyds algo to check the starting of cycle
- The starting of cycle will signify the repeating number as more than 1 will be pointing to it.
- Same we can't implement in problem (7) as index may be out of array index

7. Find Missing/ Repeating Number (Given num from 1-n, one is missed and one is repeated)
- Can't use floyd's cycle as obviously one number may be pointing more than (n-1)
- Better way is to use algebra | Sum of 1 to N - > N* (N+1) / 2 | Find sum of given nums
- Find sum of sq. N * (N+1) * (2 N + 1) / 6  | Find sq of sum of given num
 x y z = A
 x y y = B
 ----------
 z - y = A - B
 ----------

 x2 + y2 + z2 = M
 x2 + y2 + y2 = N
 -------------
 z2 - y2 = M - N 
 OR
 (z+y) (z-y) = M-N
 OR
 z+y = (M-N)/(z-y)
 -------------
- We have both z-y & z+y both repeating(y) and missing(z) which can be found now

8. Russian doll Envelopes
- Clearly DP problem can be done using memoization - O(N^2)
- BUT! For large input O(N^2) will give TLE, hence use this trick to solve it
- Sort the width and now we can apply LIS to the height
- * Make sure to reverse sort the height when width is same (so we don't pick the same width)

9. Merge without extra space
- Q) [...],  [....] both are sorted and sort as if both were one
- â­ï¸ Check first of 2nd and last of first ( and swap if 2nd has smaller item that last of 1st )
- Simple reason because we know 1st array will contain all smaller of both array's
- Now keep shifting index and keep swapping until not required, then sort both array

10. Set Matrix Zero (complete row/column turns 0 if item is 0)
- Q is easy if extra space allowed, as we can 2 vector - row/column representing row/column and turn 0 where required
- Same thing we can do if we treat first row/column as that extra vector
- Here it's just that we need to turn complete first row/column to zero at last when everything else is done
- For that we will need some flags to know if at last we need to convert 1st row/column to 0

11. Pascals Triangle
- Along with simple way of finding all rows in Pascals triangle
- We can make use of " nCr" to find nth row and rth column item in O(1)
- Also to find nth row complete, we see the simple patter of nCr, nCr+1, nCr+2...
- Which is basically multiplication to previous item & can be done in O(N)

12. Next Permutation
- Important to understand that 1,2,4,3 -> next permute is 1,3,2,4 and not 1,3,4,2
- First we are finding the index where value decreased as compared to it's next one
- This is the ind which can be replaced with any of the num from right, but which one?
- The one which is greater but closest to ind, Make sure to sort as values after swapping to the ind may not be ascending!

13. Inversion Counts
- If [5, 3, 2] -> 2 inversion counts are present -> {5, 3}, {3, 2}
- O(N^2) is simple, but we will be required to find better... basic comparisons are needed so motive is to reduce comparisons
- Now as we need to find where left>right, this is same thing we check in merge part of merge sort, and there ...
- If left>right, we can simply result+=(everything from left to mid) as all of them will form pair with right (Complexity remains same O(NlogN))

14. EASY(Best Time to buy/sell stocks, wolves of wolf street)
- Greedily approach this problem
- Keep minimum found at any point and keep checking with prices to get max

15. Rotate Image (2d Array)
- See solution first, it's nothing but transpose with rows reversed
- Must know how to transponse a matrix (changing rows to columns)