1. Inversion Count/ Reverse Pair ( both similar question )
- Basically we need to reduce complexity from O(N^2) to O(NlogN)
- And things could be little better we have have 2 sorted array where we can check the requirement
- And merge sort we have these arrays and hence we can easlily check it there
- üåü In Reverse Pair, the method where we check is important as that logic is little tricky yet easy!

2. Unique Path Problem (Google Interview)
- Use recursion for (2^N)
- Use DP for O(N^2)
- Use Optimised space in tabular
- üåü Use combinations - O(N) -> RRD, RDR...

3. Dutch National Flag Algorithm/ Sort colors/ Sort 0, 1, 2
- In a single pass it's required to be done, with constant space
- DNF says take 3 ptr - low, mid, high
- Low's left contains 0, high's right will contain 2
- swap mid[i] with left if 0, if 2-swap with high
- move ptr accordingly!

4. Linked List Cycle II 
- Important to understand algorithm (If not known cant do the question)
- Important to understand how the same algo can work for 'Duplicate Element Question'
- 2 things are stated in algo 1) if there is cycle 2) start point of cycle
- After finding merger of fast and slow, just take another slow from head & keep moving 1 step (merger will be start of cycle)

5. Maximum Product Subarray
- Important to understand that array can have both -ve and 0
- Logic is to carry smallest and largest number possible everytimes
- So that if other - comes we can change that lowest to bigest or bigest to lowest(so it can become largest later when - comes again)
- Understand recursive approach in order to understand iterative(exactly same as recursion)

6. Find Duplicate Number in 1+N, numbered from 1-N
- clearly all items will be pointing inside the array itself
- Hence we can go for floyds algo to check the starting of cycle
- The starting of cycle will signify the repeating number as more than 1 will be pointing to it.
- Same we can't implement in problem (7) as index may be out of array index

7. Find Missing/ Repeating Number (Given num from 1-n, one is missed and one is repeated)
- Can't use floyd's cycle as obviously one number may be pointing more than (n-1)
- Better way is to use algebra | Sum of 1 to N - > N* (N+1) / 2 | Find sum of given nums
- Find sum of sq. N * (N+1) * (2 N + 1) / 6  | Find sq of sum of given num
 x y z = A
 x y y = B
 ----------
 z - y = A - B
 ----------

 x2 + y2 + z2 = M
 x2 + y2 + y2 = N
 -------------
 z2 - y2 = M - N 
 OR
 (z+y) (z-y) = M-N
 OR
 z+y = (M-N)/(z-y)
 -------------
- We have both z-y & z+y both repeating(y) and missing(z) which can be found now

8. Russian doll Envelopes
- Clearly DP problem can be done using memoization - O(N^2)
- BUT! For large input O(N^2) will give TLE, hence use this trick to solve it
- Sort the width and now we can apply LIS to the height
- * Make sure to reverse sort the height when width is same (so we don't pick the same width)

9. Merge without extra space
- Q) [...],  [....] both are sorted and sort as if both were one
- ‚≠êÔ∏è Check first of 2nd and last of first ( and swap if 2nd has smaller item that last of 1st )
- Simple reason because we know 1st array will contain all smaller of both array's
- Now keep shifting index and keep swapping until not required, then sort both array

10. Set Matrix Zero (complete row/column turns 0 if item is 0)
- Q is easy if extra space allowed, as we can 2 vector - row/column representing row/column and turn 0 where required
- Same thing we can do if we treat first row/column as that extra vector
- Here it's just that we need to turn complete first row/column to zero at last when everything else is done
- For that we will need some flags to know if at last we need to convert 1st row/column to 0